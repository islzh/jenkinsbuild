#!/bin/bash

set -o monitor
set -o nounset

main () {
    #
    # CONFIGURATIONS START
    #
    local JENKINS_URL=${JENKINS_URL-}
    local JENKINS_USER=${JENKINS_USER-}
    local JENKINS_TOKEN=${JENKINS_TOKEN-}
    local JENKINS_JOB_NAME=${JENKINS_JOB_NAME-}
    local JENKINS_SRC_DIR=${JENKINS_SRC_DIR-'.'}
    #
    # CONFIGURATIONS END
    #
    local daemon_only param data with_param no_with_param
    local version="0.4.1"
    local lupdate="2022-05-12"
    with_param=${JENKINS_WITH_PARAMETER:-0}
    while test $# -ge 1
    do
        case $1 in
        -d|--daemon-only)
            daemon_only=1
            shift
            ;;
        -k|--kill-daemon)
            KillDaemon
            exit
            ;;
        -p|--parameter)
            test $# -lt 2 && err "switch $1 requires a value"
            printf -v param "%s%s\n" "${param-}" "$2"
            shift 2
            ;;
        -w|--with-parameter)
            with_param=1
            no_with_param=0
            shift
            ;;
        -n|--no-with-parameter)
            no_with_param=1
            with_param=0
            shift
            ;;
        -h|-\?|--help)
            ShowHelp
            printf "\n"
            ShowVersion
            exit 0
            ;;
        --version)
            ShowVersion
            exit 0
            ;;
        *)
            err "invalid argument: $1"
            ;;
        esac
    done
    GitDaemon || return
    FormatParam
    CallApi
}

KillDaemon () {
    ps -afW | grep -q 'git-daemon\.exe' || return 0
    taskkill //f //im git-daemon.exe 1>/dev/null
}

GitDaemon () {
    KillDaemon || return
    git daemon --export-all --enable=upload-archive \
        --base-path="$JENKINS_SRC_DIR" &
    test "${daemon_only-}" && exit
    return 0
}

FormatParam () {
    local IFS
    test ! "${param-}" && return
    printf -v IFS "\n"
    test "${no_with_param:-0}" -eq 0 ||
        err "-p or --parameter conflicts with -n or --no-with-parameter"
    with_param=1
    for p in $param
    do
        printf -v data "%s%s " "${data-}" "--data $p"
    done
}

CallApi () {
    local api="build"
    test "${JENKINS_USER-}" &&
        test "${JENKINS_TOKEN-}" &&
        test "${JENKINS_URL-}" &&
        test "${JENKINS_JOB_NAME-}" ||
        err "JENKINS_USER, JENKINS_TOKEN, JENKINS_URL, or JENKINS_JOB_NAME undefined" \
        "Try 'jenkinsbuild --help' for more information."
    test "$with_param" -eq 0 || api="buildWithParameters"
    git branch -f jenkinsbuild
    curl --silent --show-error --request POST \
        --user $JENKINS_USER:$JENKINS_TOKEN \
        $JENKINS_URL/job/$JENKINS_JOB_NAME/$api \
        ${data-}
}

ShowHelp () {
cat <<EOF
Use without argument to build current branch in a specific Jenkins job.
Use with -d (or --daemon-only) to start git-deamon only.
Use with -k (or --kill-daemon) to kill git-daemon and exit.
Use with -w (or --with-parameter) for Jenkins jobs having parameters.
Use with -n (or --no-with-parameter) for Jenkins jobs without parameter.
 This is the default, but you can set environment variable
 JENKINS_WITH_PARAMETER to 1 to set --with-parameter as the default.
Use with -p (or --parameter) to specify build parameters. This implies
 --with-parameter. It can be used multiple times to specify more
 than one parameters. E.g., below command specified 2 parameters.
 jenkinsbuild -p VAR1=value1 -p VAR2=value2

Following steps are required to be done before first use.

1. In Jenkins job, set git branch to build to "jenkinsbuild".
2. Set following environment variables.
    JENKINS_URL: Jenkins URL such as http://example.com:8080
    JENKINS_USER: Jenkins user name
    JENKINS_TOKEN: API token of JENKINS_USER
    JENKINS_JOB_NAME: Name of the job to build
    JENKINS_SRC_DIR: Directory of source code to build from
EOF
}

ShowVersion () {
cat <<EOF
version: $version
lastupdated: $lupdate
author: johnny-appleseed <liuzhaohui@inspur.com>
EOF
}

err () {
    local msg=${1-"unspecific error"}
    >&2 printf "error: %s\n" "$1"
    shift
    test $# -gt 0 && >&2 printf "%s\n" "$@"
    exit 1
}

main "$@"
